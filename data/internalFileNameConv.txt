This file is meant to define the convention used for the internalFile.json file 

Anytime a developer want to extend this tool with another static analyzer she has to create a json representation 
of the static analyzer using the conventions below, and add that json object into the tools object  
which is an internalFile.json   

regard anything in () as comments that elaborate on the convention

{ 
"tools":{

    "static-analyzer1":{ ... }

    "static-analyzer2":{ ... } 

    "NAME OF STATIC ANALYZER" (a short name analyzer can be ref to as) 
        :{ 
            "toolName": "NAME OF STATIC ANALYZER"
            "fileTypes": [TYPES SUPPORTED] (a string list of extensions for src code that the analyzer supports) 
            "invokeCommands": [INVOKE COMMANDS](a string list of commands that will be executed via the shell in the order
                                of left to right, with the goal of calling the static analyzer. The last command 
                                should always be the one invokes the static analyzer, the other commands can be 
                                preparatory steps needed for the specific analyzer to start. ie. starting a server ) 
            "method": "METHOD TO GET REPORT" (a string that indicates the method of getting the json report generated by the static
                                            analyzer after its scan. At the moment, two methods are supported: "API",
                                            where an API call needs to be made to get the json report, and "FILE", where the 
                                            json report can be found on a local file, if the static analyzer produces a CL json report 
                                            the report will be redirected to one of the output files in mem/analyzerOutput, so one can 
                                            act as if the report is retrievable from a local file) 
            "requestCommands": [REQUEST COMMANDS] (a list of commands that are executed in order from left with the goal of reading the analyzer's 
                                                    json report. If the method value is "FILE" then the last command should be the address of the local json 
                                                    report file, and the previous commands are preparatory commands executed via the shell ie. unlocking permissions or 
                                                    formatting the output. If the method value is "API" then the last command should be a GET api call that retrieves the 
                                                    json report file, the previous commands should be preparatory commands that are executed as POST api calls, ie authentication) 
            "sucRetCodes": "REG EX OF INTS" (a regexp that matches to the string version of integers that correspond to a successful execution of the analyzer, some analyzers like pylint
                                                            have other exit codes besides 0 that are used when there are policy violations in the src code that was scanned, these
                                                            exit codes should also be put in this list considering that the analyzer still executed successfully) 
            "output": "OUTPUT FILE" (relative path from mem/temp to file to redirect the output of the process that executes the invoke commands. For analyzers who generates CL json reports, its output and, thus 
                                    the report is redirected to this file. So one can refer to it in the requestCommands list.) 
            "error": "ERROR FILE"   (relative path from mem/temp to file where std error output should be redirected to from the process that is executing the invoke commands) 
            "mapping": { (Different static analyzers use different terms and formats to refer to the same type of data. This mapping object helps extract data from these analyzer specific reports 
                            for the generation of the general report. The mapping object dictionary maps the general terms used in the general report to the specific terms of each analyzer 
                                        the program makes three assumptions about the json reports 
                                            1. there's a list of issues  
                                            2. this list of issues is 1 json dictionary object; not in deeper layers of json objs 
                                            3. each issue is dictionary object that holds data regarding the file that the issue was detected, the line location of the issue, and the 
                                            description of it  
                                    if the output doesn't satisfy this prior commands in requestCommands list can reformat the output)  
                        "vulList": "KEY REFERING TO LIST OF ISSUES" (The key in the analyzer's json report that refers to the list of issues)   
                        "file": "KEY REFERING TO FILE OF ISSUE"  
                        "description": "KEY REFERING TO DESCRIPTION OF ISSUE" 
                        "location": "KEY REFERING TO LINE LOCATION OF ISSUE" (if the value associated with line location is not an integer on the analyzer's report, the tool will read it as NO LOCATION)

                }

    }


}
}

