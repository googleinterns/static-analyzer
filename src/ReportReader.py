import json 
import requests  
import Utils  
import subprocess
from Scheduler import Task 

#The ReportReader class is responsible for using the scattered json reports generated by the successful analyzer's scans 
#to create one general report that contains all of the data from the analyzer specfic reports  
#The constructor takes in a schedule, which is a list of task objects, task objects are defined in scheduler.py, and intFile 
# which is the deseralized json internal file  
# ReportReader works by finding each of the json reports generated by the analyzer's scans (either stored locally or on a server), 
# after it finds an analyzer specific report, using the mapping info provided in the internal file, it scrapped the specfic report 
# and adds data into the general report

class ReportReader:  

    #To-Do: 
        #finish get report (local & cli) functions  
        #error prevention (espically keys errors, connection errors)
        #other details for report 
        #multi cmd calls 
        #dont get files when scans fail 
        #might not need request ovjects sinbce task hhas all info already 

    #As far as I know three ways to get the json reports of statix analyzers based off 
    #of where they put them and acsess 
    #1. get local file 
    #2. get CL output 
    #3. api call from server 
    #Thus I'll make functions that support all three of these methods and have the user specficyu what method to use and how  

    #Overall workflow of ReportReader
        #public interfacing function parseReports 
        #collect all generated reports as report objects in array 
        #for each report object create vulnarbitly objects 
        #create big strings from vulnrability objects  

  
    def __init__(self, schedule, intFile): 
        self.__schedule = schedule   
        self.__intFile = intFile
        
         
    #The parseReports function is the public interfacing function of ReportReader 
    #it finds and generates report objects for the json reports created by the sucsesful analyzer scans 
    #it then uses the mapping info from the internal file to scrap info from the specfic reports and append to the general report
    def parseReports(self):  
        reports = []   
        genReport = ""

        #load report strings into array 
        requests = self.__getRequests() 
        for request in requests:  
           
            if (request.method == "FILE"): 
                reports.append(Report(request.toolName, self.__getLocalFile(request.requestCommands))) 
            elif(request.method == "API"):  
                #returns strign from file
                 reports.append(Report(request.toolName,self.__getApiFile(request.requestCommands)))    
            elif(request.method == "CL"): 
                print("run file commands")  
            else:  
                Utils.printErrorMessage("INVALID REQUEST METHOD")  
         
        for report in reports: 
            repObj = json.loads(report.json)   
            mapping = self.__intFile["tools"][report.toolName]["mapping"] 
            vuls = repObj[mapping["vulList"]]  
            for vul in vuls: 
                genReport = self.__addToGenReport(genReport=genReport, vul=vul, mapping = mapping, toolName=report.toolName )  


        return genReport




        

        


    #gets the method of how to reterive report
    def __getRequests(self):  
        requests = []
        #loads internal file 
        # creates method objects for each tool in schedule 
        # based on internal file  
        # adds request objects into list  

       
       
        #for the tools in each task in the schedule, get request methods/info
        for task in self.__schedule: 
            if task.status == True:    
                requests.append(Request(toolName = task.toolName,method = task.method, requestCommands = task.requestCommands)) 
        
        return requests  


    #private function that appends an analyzer's report's issue to the general report  
    #it takes in the genReport string, which is thestiring contents of the general report  
    #vul object, which is the deseralized json representation of the issue from the specfic report 
    #mapping object which is the deseralized json dictionary that holds the mapping info between the specfic and general report 
    #toolName string, which is th ename of the tool of which thsi issue originated from; The name used is the one defined in the internal file  
    #for a given issue/vulrnability the function maps data presented in the specfic report to the counterpart words thart describe the data in the general report 
    # it appends the strings created by this mapping into the overall general report string  
    def __addToGenReport(self, genReport, vul, mapping, toolName): 
        genReport += "\n" 
        genReport += "description: " + vul[mapping["description"]] + "\n" 
        genReport += "toolName: " + str(toolName) + "\n"  
        genReport += "file: " + vul[mapping["file"]] + "\n"  
        #some issues may not have locations
        try:
            genReport += "location: " + str(vul[mapping["location"]]) + "\n"  
        except KeyError:  
            genReport += "location: " + "NO LOCATION" + "\n" 
            

        return genReport 


    

     
#private function reponsible for reteriving the json contents of a local specfic report 
#takes in the requestComnmands list, a list of strings that will be used ot acsess the contents of the local file 
#the last string in the list must be the path to the specfic report, any possible prior strings shoudl be shell executable commands 
#that help with the acsessing and parsing of the local file 
#the function works by executing each command string prior to the last one via the shell. it then uses the last strng as a path to  
#open and read the json file, returning its contents.  
    def __getLocalFile(self, requestCommands): 
        length = len(requestCommands)
        curr = 0
        for command in requestCommands:  
            curr +=1  
            if(curr == length):  
                with open(command) as output:
                    return output.read() 
            else: 
                subprocess.run(command, shell=True)  
        subprocess.run(command,shell = True,stdout=output).returncode  

#private function that is responsible for reterving json contents of file stored in a server via API requests 
#the function takes in the requestCommands list, a list of api request strings where the last string should be a get request that retirives  
#the json of the specfic report. And the string request prior to last should be prepatory post request 
#the function works by making a post request using each string prior to the last one and then making a get request using the final string 
#to reterive and then return the string json contents of the specfic report
    def __getApiFile(self,requestCommands):  
        #method objects contain strings that help get files 
        #an API method will contain uri's for acsessing the report 

         
        #last api call is for report, others may be for auth, 
        length = len(requestCommands)
        curr = 0
        for command in requestCommands:  
            curr +=1  
            if(curr == length):  
                jsonReport = requests.get(command).text 
                return jsonReport 
            else: 
                requests.post(command) 

        

            
        

#class that holds data regardign a specfic report from an analyzer's successful scan 
#constructor takes in toolName which is the internal file name of the tool and json 
#which is the strign contents of the json specfic report 
class Report: 
    def __init__(self, toolName, json): 
        self.toolName = toolName 
        self.json = json   
        
    
    
class Request: 
    def __init__(self, toolName, method, requestCommands): 
        self.toolName = toolName 
        self.method = method 
        self.requestCommands = requestCommands  

    

