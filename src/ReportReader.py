import json 
import requests  
import Utils  
import subprocess 
import time
from Scheduler import Task  

#The ReportReader class is responsible for using the scattered json reports generated by the successful analyzer's scans 
#to create one general report that contains all of the data from the analyzer specfic reports  
#The constructor takes in a schedule, which is a list of task objects, task objects are defined in scheduler.py, and intFile 
# which is the deseralized json internal file  
# ReportReader works by finding each of the json reports generated by the analyzer's scans (either stored locally or on a server), 
# after it finds an analyzer specific report, using the mapping info provided in the internal file, it scrapped the specfic report 
# and adds data into the general report

class ReportReader:  

    #As far as I know three ways to get the json reports of statix analyzers based off 
    #of where they put them and acsess 
    #1. get local file 
    #2. get CL output 
    #3. api call from server 
    #Thus I'll make functions that support all three of these methods and have the user specficyu what method to use and how  

    #Overall workflow of ReportReader
        #public interfacing function parseReports 
        #collect all generated reports as report objects in array 
        #for each report object create vulnarbitly objects 
        #create big strings from vulnrability objects  

  
    def __init__(self, schedule, intFile): 
        self.__schedule = schedule   
        self.__intFile = intFile
        
         
    #The parseReports function is the public interfacing function of ReportReader 
    #it finds and generates report objects for the json reports created by the sucsesful analyzer scans 
    #it then uses the mapping info from the internal file to scrap info from the specfic reports and append to the general report
    def parseReports(self):  
        reports = []   
        genVulList = []
        
        Utils.printNotiMessage("PROVIDING TIME FOR ANALYZER REPORT UPDATES...") 
        time.sleep(120.00)  
        Utils.printNotiMessage("PROCESSING REPORTS...")


        #load report strings into array 
        for task in self.__schedule:  
           if task.status == True:
            if (task.method == "FILE"):  
                report = self.__getLocalFile(toolName=task.toolName, requestCommands=task.requestCommands) 
                if report != "FAILED":
                    reports.append(Report(task.toolName, report))  
            elif(task.method == "API"):  
                #returns strign from file 
                report = self.__getApiFile(toolName=task.toolName, requestCommands=task.requestCommands) 
                if report != "FAILED":
                    reports.append(Report(task.toolName,report))    
            else:  
                Utils.printErrorMessage("INVALID REQUEST METHOD")  
         
        for report in reports: 
            repObj = json.loads(report.json)   
            mapping = self.__intFile["tools"][report.toolName]["mapping"]  
            try:
                vuls = repObj[mapping["vulList"]]  
                for vul in vuls: 
                    genVulList.append(self.__addToGenReport( vul=vul, mapping = mapping, toolName=report.toolName ) )  
            except KeyError: 
                Utils.printErrorMessage("INVALID REPORT RESPONSE FROM " + report.toolName)   

        #add overall infomation/ create whole object 
        count = len(genVulList)  
        if count == 0: 
            status = True  
        else: 
            status = False
        genRepObj ={ 
            "passed": status, 
            "numOfVuls": count, 
            "listOfVuls": genVulList
        } 

        return json.dumps(genRepObj).replace("SATool:", "")


    #private function that appends an analyzer's report's issue to the general report  
    #it takes in the genReport string, which is thestiring contents of the general report  
    #vul object, which is the deseralized json representation of the issue from the specfic report 
    #mapping object which is the deseralized json dictionary that holds the mapping info between the specfic and general report 
    #toolName string, which is th ename of the tool of which thsi issue originated from; The name used is the one defined in the internal file  
    #for a given issue/vulrnability the function maps data presented in the specfic report to the counterpart words thart describe the data in the general report 
    # it appends the strings created by this mapping into the overall general report string  
    def __addToGenReport(self, vul, mapping, toolName):   
        try:
            locStr = vul[mapping["location"]] 
        except KeyError:  
            locStr = -1  
        
        genVulObj = { 
            "description": vul[mapping["description"]], 
            "toolName": str(toolName), 
            "file": vul[mapping["file"]], 
            "location": locStr             
        }

        return genVulObj


    

     
#private function reponsible for reteriving the json contents of a local specfic report 
#takes in the requestComnmands list, a list of strings that will be used ot acsess the contents of the local file 
#the last string in the list must be the path to the specfic report, any possible prior strings shoudl be shell executable commands 
#that help with the acsessing and parsing of the local file 
#the function works by executing each command string prior to the last one via the shell. it then uses the last strng as a path to  
#open and read the json file, returning its contents.  
    def __getLocalFile(self, toolName, requestCommands): 
        length = len(requestCommands)
        curr = 0
        for command in requestCommands:  
            curr +=1  
            if(curr == length): 
                try: 
                    with open(command) as output:
                        return output.read()  
                except FileNotFoundError: 
                    Utils.printErrorMessage("FAILED TO RETERIVE " +toolName + "'s REPORT") 
            else:  
                try: 
                    subprocess.run(command, shell=True) 
                except FileNotFoundError: 
                    Utils.printErrorMessage("FAILED TO RETERIVE " +toolName + "'s REPORT")
        subprocess.run(command,shell = True,stdout=output).returncode  

#private function that is responsible for reterving json contents of file stored in a server via API requests 
#the function takes in the requestCommands list, a list of api request strings where the last string should be a get request that retirives  
#the json of the specfic report. And the string request prior to last should be prepatory post request 
#the function works by making a post request using each string prior to the last one and then making a get request using the final string 
#to reterive and then return the string json contents of the specfic report
    def __getApiFile(self,toolName,requestCommands):  
        #method objects contain strings that help get files 
        #an API method will contain uri's for acsessing the report 

         
        #last api call is for report, others may be for auth, 
        length = len(requestCommands)
        curr = 0
        for command in requestCommands:  
            curr +=1  
            if(curr == length):   
                try:
                    jsonReport = requests.get(command,timeout=10.00).text 
                    return jsonReport 
                except requests.exceptions.RequestException: 
                    Utils.printErrorMessage("FAILED TO RETERIVE " +toolName + "'s REPORT")  
                    return "FAILED"
            else:  
                try:
                    requests.post(command, timeout=10.00)  
                except requests.exceptions.RequestException: 
                    Utils.printErrorMessage("FAILED TO RETERIVE " +toolName + "'s REPORT")  
                    return "FAILED"
                    break


        

            
        

#class that holds data regardign a specfic report from an analyzer's successful scan 
#constructor takes in toolName which is the internal file name of the tool and json 
#which is the strign contents of the json specfic report 
class Report: 
    def __init__(self, toolName, json): 
        self.toolName = toolName 
        self.json = json   
       
        
    
      

    

